# Plan: Pitch Control Module

**Phase:** 2 - Pitch Control Module
**Plan:** 02-01
**Status:** Complete

## Objective

Implement Spearman 2017 influence-based pitch control algorithm that computes team control probability at each grid point.

Purpose: Enable spatial dominance visualization showing which team controls each area of the pitch.
Output: `src/pitch_control.py` with grid generation, influence functions, and control calculation.

## Context

**Dependencies:**
- Phase 1 complete: `src/velocity.py` provides player velocities

**Algorithm (from PROJECT.md):**
- Model: Spearman 2017 influence-based pitch control
- Grid: 53×34 points at 2m resolution (105m × 68m pitch)
- Constants: REACTION_TIME=0.7s, MAX_SPEED=13.0 m/s
- Influence based on time-to-intercept with sigmoid transformation

**Key Files:**
- `src/velocity.py` - Provides calculate_velocities, smooth_velocities, clamp_velocities
- `src/compactness.py` - Example of similar analytical module

---

## Tasks

### Task 1: Create module skeleton with grid generation
**File:** `src/pitch_control.py`

Create the module with:
- Module docstring explaining purpose
- Constants: `REACTION_TIME = 0.7`, `MAX_SPEED = 13.0`, `GRID_RESOLUTION = 2`, `PITCH_LENGTH = 105`, `PITCH_WIDTH = 68`
- Import dependencies: numpy

Implement `create_pitch_grid()`:
```python
def create_pitch_grid(
    pitch_length: float = PITCH_LENGTH,
    pitch_width: float = PITCH_WIDTH,
    resolution: float = GRID_RESOLUTION
) -> tuple:
    """
    Generate grid points for pitch control calculation.

    Args:
        pitch_length: Pitch length in meters (default 105)
        pitch_width: Pitch width in meters (default 68)
        resolution: Grid spacing in meters (default 2)

    Returns:
        (x_grid, y_grid): 2D numpy arrays of grid coordinates
    """
```

Logic:
- Use np.arange to create x points from 0 to pitch_length with resolution spacing
- Use np.arange to create y points from 0 to pitch_width with resolution spacing
- Use np.meshgrid to create 2D grid arrays

**Verification:** `python -c "from src.pitch_control import create_pitch_grid; x,y = create_pitch_grid(); print(f'Grid shape: {x.shape}')"` returns `Grid shape: (35, 54)` (approximately 53×34)

---

### Task 2: Implement influence calculation functions
**File:** `src/pitch_control.py`

Implement `time_to_intercept()`:
```python
def time_to_intercept(
    player_pos: tuple,
    player_vel: tuple,
    target_pos: tuple,
    reaction_time: float = REACTION_TIME,
    max_speed: float = MAX_SPEED
) -> float:
    """
    Calculate time for player to reach target position.

    Args:
        player_pos: (x, y) player position
        player_vel: (vx, vy) player velocity
        target_pos: (x, y) target grid point
        reaction_time: Time before player can react (default 0.7s)
        max_speed: Maximum player speed (default 13.0 m/s)

    Returns:
        Time in seconds to reach target
    """
```

Logic:
- Calculate distance from player to target
- Account for current velocity direction (dot product with direction to target)
- Simple model: time = reaction_time + distance / max_speed
- More accurate: adjust for velocity component toward target

Implement `player_influence()`:
```python
def player_influence(
    time_to_intercept: float,
    sigma: float = 0.5
) -> float:
    """
    Convert time-to-intercept to influence value using sigmoid.

    Args:
        time_to_intercept: Time in seconds
        sigma: Sigmoid steepness parameter

    Returns:
        Influence value between 0 and 1
    """
```

Logic:
- Influence = 1 / (1 + exp(time_to_intercept / sigma))
- Closer (less time) = higher influence
- Sigmoid provides smooth transition

**Verification:** Functions handle edge cases (zero velocity, player at target)

---

### Task 3: Implement main pitch control function with tests
**File:** `src/pitch_control.py`

Implement `compute_pitch_control()`:
```python
def compute_pitch_control(
    home_positions: dict,
    away_positions: dict,
    home_velocities: dict = None,
    away_velocities: dict = None
) -> np.ndarray:
    """
    Compute pitch control for each grid point.

    Args:
        home_positions: {player_id: (x, y)} home team positions
        away_positions: {player_id: (x, y)} away team positions
        home_velocities: {player_id: (vx, vy)} home velocities (optional)
        away_velocities: {player_id: (vx, vy)} away velocities (optional)

    Returns:
        2D numpy array of control values:
        - 0.0 = full away control
        - 0.5 = contested
        - 1.0 = full home control
    """
```

Logic:
- Generate grid with create_pitch_grid()
- For each grid point:
  - Calculate time-to-intercept for all players
  - Sum influences per team
  - Control = home_influence / (home_influence + away_influence)
- Return 2D array matching grid shape

Add `if __name__ == "__main__":` test block with:
- Test 1: Grid generation (verify shape and bounds)
- Test 2: Time-to-intercept (known distance → expected time)
- Test 3: Player influence (sigmoid behavior)
- Test 4: Pitch control (simple scenario with known result)

**Verification:** `python src/pitch_control.py` runs all tests with checkmarks

---

## Success Criteria

- [ ] `src/pitch_control.py` exists with all functions
- [ ] `create_pitch_grid()` returns correct grid dimensions
- [ ] `time_to_intercept()` calculates player arrival time
- [ ] `player_influence()` applies sigmoid transformation
- [ ] `compute_pitch_control()` returns 2D control array
- [ ] All module tests pass
- [ ] Code follows existing conventions (snake_case, docstrings)

## Dependencies

- NumPy (already in requirements.txt)
- No new dependencies required

## Estimated Scope

3 tasks, ~200 lines of code

---

*Plan created: 2026-01-09*
