# Plan: Velocity Module

**Phase:** 1 - Velocity Module
**Plan:** 01-01
**Status:** Complete

## Objective

Create a velocity calculation module that computes player velocities from frame-to-frame position deltas, with EMA smoothing to handle noisy tracking data.

## Context

The pitch control algorithm requires player velocities to calculate time-to-intercept for each grid point. The PFF tracking data provides positions at 29.97 fps but no velocity data. We need to derive velocities from position changes and smooth them to reduce noise.

## Tasks

### Task 1: Create velocity module skeleton
**File:** `src/velocity.py`

Create the module with:
- Module docstring explaining purpose
- Constants: `MAX_SPEED = 13.0`, `EMA_ALPHA = 0.3`, `FPS = 29.97`
- Import dependencies: numpy

**Verification:** File exists with constants defined

---

### Task 2: Implement calculate_velocities function
**File:** `src/velocity.py`

```python
def calculate_velocities(
    current_positions: dict,
    previous_positions: dict,
    fps: float = 29.97
) -> dict:
    """
    Calculate raw velocities from position deltas.

    Args:
        current_positions: {player_id: (x, y)} current frame
        previous_positions: {player_id: (x, y)} previous frame
        fps: Frames per second

    Returns:
        {player_id: (vx, vy)} velocities in m/s
    """
```

Logic:
- For each player in both frames, compute delta / time_delta
- time_delta = 1.0 / fps
- Handle missing players (return zero velocity)

**Verification:** Function returns correct velocities for test data

---

### Task 3: Implement smooth_velocities function
**File:** `src/velocity.py`

```python
def smooth_velocities(
    current_velocities: dict,
    previous_smoothed: dict,
    alpha: float = 0.3
) -> dict:
    """
    Apply EMA smoothing to velocities.

    Args:
        current_velocities: Raw velocities this frame
        previous_smoothed: Smoothed velocities from previous frame
        alpha: EMA smoothing factor (higher = more responsive)

    Returns:
        {player_id: (vx, vy)} smoothed velocities
    """
```

Logic:
- EMA formula: smoothed = alpha * current + (1 - alpha) * previous
- Handle new players (use current as initial)
- Handle missing players (decay previous)

**Verification:** Function smooths noisy input correctly

---

### Task 4: Implement clamp_velocities function
**File:** `src/velocity.py`

```python
def clamp_velocities(
    velocities: dict,
    max_speed: float = 13.0
) -> dict:
    """
    Clamp velocity magnitudes to maximum realistic speed.

    Args:
        velocities: {player_id: (vx, vy)}
        max_speed: Maximum allowed speed in m/s

    Returns:
        {player_id: (vx, vy)} clamped velocities
    """
```

Logic:
- Calculate speed = sqrt(vx² + vy²)
- If speed > max_speed, scale down proportionally
- Preserve direction

**Verification:** No velocity exceeds max_speed

---

### Task 5: Add module tests
**File:** `src/velocity.py`

Add `if __name__ == "__main__":` test block with:
- Test 1: Basic velocity calculation (known positions → expected velocity)
- Test 2: EMA smoothing (noisy input → smooth output)
- Test 3: Velocity clamping (extreme values → clamped)
- Test 4: Missing player handling

**Verification:** All tests pass with ✅

---

## Success Criteria

- [x] `src/velocity.py` exists with all functions
- [x] `calculate_velocities()` returns correct velocities from position deltas
- [x] `smooth_velocities()` applies EMA smoothing correctly
- [x] `clamp_velocities()` limits speeds to MAX_SPEED
- [x] All module tests pass
- [x] Code follows existing conventions (snake_case, docstrings)

## Dependencies

- NumPy (already in requirements.txt)
- No new dependencies required

## Estimated Scope

5 tasks, ~150 lines of code

---

*Plan created: 2026-01-09*
